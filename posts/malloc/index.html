<!DOCTYPE html><html lang="en-US" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="malloc.c Analysis" /><meta name="author" content="nonetype" /><meta property="og:locale" content="en_US" /><meta name="description" content="malloc analysis note" /><meta property="og:description" content="malloc analysis note" /><link rel="canonical" href="https://nonetype.kr/posts/malloc/" /><meta property="og:url" content="https://nonetype.kr/posts/malloc/" /><meta property="og:site_name" content="do:pwn()" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-09-30T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="malloc.c Analysis" /><meta name="twitter:site" content="@nonetype_pwn" /><meta name="twitter:creator" content="@nonetype" /><meta name="google-site-verification" content="googlef894166fa16bb09c" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"nonetype"},"description":"malloc analysis note","url":"https://nonetype.kr/posts/malloc/","headline":"malloc.c Analysis","dateModified":"2020-12-02T12:40:53+08:00","datePublished":"2019-09-30T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nonetype.kr/posts/malloc/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>malloc.c Analysis | do:pwn()</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="do:pwn()"><meta name="application-name" content="do:pwn()"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-HLXHMG7DE3"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-HLXHMG7DE3'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/me.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">do:pwn()</a></div><div class="site-subtitle font-italic">AttributeError - 'NoneType'</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/nonetype" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/nonetype_pwn" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['exploit','kakao.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>malloc.c Analysis</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>malloc.c Analysis</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> nonetype </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Sep 30, 2019, 12:00 AM +0800" prep="on" > Sep 30, 2019 <i class="unloaded">2019-09-30T00:00:00+08:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 2, 2020, 1:40 PM +0900" prefix="Updated " > Dec 2, 2020 <i class="unloaded">2020-12-02T12:40:53+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5212 words">28 min</span></div></div><div class="post-content"><p>malloc analysis note</p><blockquote><p>본 문서에서 분석하는 malloc.c(glibc2.23) 소스 코드는 <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz">여기</a>에서 다운로드 받을 수 있습니다.</p></blockquote><hr /><h1 id="목차">목차</h1><ul><li><a href="#목차">목차</a><li><a href="#1-whats-heap">1. What’s Heap?</a><li><a href="#2-the-heap-chunk">2. The Heap Chunk</a><ul><li><a href="#p-prev_inuse">P (PREV_INUSE)</a><li><a href="#m-is_mmapped">M (IS_MMAPPED)</a><li><a href="#a-non_main_arena">A (NON_MAIN_ARENA)</a></ul><li><a href="#3-management-of-chunk--bin">3. Management of Chunk &amp; Bin</a><ul><li><a href="#3-1-fast-bin">3-1. Fast bin</a><li><a href="#3-2-unsorted-bin">3-2. Unsorted bin</a><li><a href="#3-3-small-bin">3-3. Small bin</a><li><a href="#3-4-large-bin">3-4. Large bin</a><li><a href="#3-5-top-chunk">3-5. Top chunk</a><li><a href="#3-6-last-remainder-chunk">3-6. Last remainder chunk</a></ul><li><a href="#4-core-functions">4. Core Functions</a><ul><li><a href="#4-2-void--__libc_malloc-size_t-bytes">4-2. void * __libc_malloc (size_t bytes)</a><li><a href="#4-1-static-void--_int_malloc-mstate-av-size_t-bytes">4-1. static void * _int_malloc (mstate av, size_t bytes)</a><li><a href="#4-3-void-__libc_free-void-mem">4-3. void __libc_free (void *mem)</a><li><a href="#4-4-static-void-_int_free-mstate-av-mchunkptr-p-int-have_lock">4-4. static void _int_free (mstate av, mchunkptr p, int have_lock)</a><li><a href="#4-5-unlinkav-p-bk-fd">4-5. unlink(AV, P, BK, FD)</a></ul><li><a href="#5-error-checks">5. Error Checks</a><ul><li><a href="#5-1-checks-in-_int_malloc">5-1 checks in _int_malloc</a><li><a href="#5-2-checks-in-_int_free">5-2 checks in _int_free</a><li><a href="#5-3-checks-in-unlink">5-3 checks in unlink</a></ul><li><a href="#마치며">마치며..</a><li><a href="#references">References</a></ul><hr /><h1 id="1-whats-heap">1. What’s Heap?</h1><p>간략하게 설명하면, 프로그래머가 가변적으로 사용 가능한 메모리 영역이다. 이는 프로그래머가 유저 입력(또는 외부 입력)에 따라 유연하게 메모리를 사용할 수 있도록 도와준다.</p><p>아래와 같이 <code class="language-plaintext highlighter-rouge">#include &lt;stdlib.h&gt;</code>를 선언함으로써 <code class="language-plaintext highlighter-rouge">malloc()</code>과 <code class="language-plaintext highlighter-rouge">free()</code>함수로 동적 메모리를 사용할 수 있게 된다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"malloc(32): [%p]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="s">"ABCD"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"value: [%s]</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"free(ptr) success!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>glibc에서는 아래와 같이 <code class="language-plaintext highlighter-rouge">malloc()</code>과 <code class="language-plaintext highlighter-rouge">free()</code> 함수를 설명한다.</p><p><strong>malloc.c:525</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cm">/*
  malloc(size_t n)
  Returns a pointer to a newly allocated chunk of at least n bytes, or null
  if no space is available. Additionally, on failure, errno is
  set to ENOMEM on ANSI C systems.

  If n is zero, malloc returns a minumum-sized chunk. (The minimum
  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit
  systems.)  On most systems, size_t is an unsigned type, so calls
  with negative arguments are interpreted as requests for huge amounts
  of space, which will often fail. The maximum supported value of n
  differs across systems, but is in all cases less than the maximum
  representable value of a size_t.
*/</span>
<span class="kt">void</span><span class="o">*</span>  <span class="nf">__libc_malloc</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
<span class="n">libc_hidden_proto</span> <span class="p">(</span><span class="n">__libc_malloc</span><span class="p">)</span>

<span class="cm">/*
  free(void* p)
  Releases the chunk of memory pointed to by p, that had been previously
  allocated using malloc or a related routine such as realloc.
  It has no effect if p is null. It can have arbitrary (i.e., bad!)
  effects if p has already been freed.

  Unless disabled (using mallopt), freeing very large spaces will
  when possible, automatically trigger operations that give
  back unused memory to the system, thus reducing program footprint.
*/</span>
<span class="kt">void</span>     <span class="nf">__libc_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="n">libc_hidden_proto</span> <span class="p">(</span><span class="n">__libc_free</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">malloc()</code>과 <code class="language-plaintext highlighter-rouge">free()</code> 함수는 개발자와 OS 사이에 효율적인 heap memory 관리를 가능하게 해주지만, 개발자가 할당한 메모리의 사용이 끝나면 정확하게 <code class="language-plaintext highlighter-rouge">free()</code> 함수를 통해 메모리를 해제해 줘야 하고, 해제한 메모리의 포인터는 즉각 폐기해야 한다. 이는 추후에 설명할 Use After Free 취약점과 관련이 있다.</p><hr /><h1 id="2-the-heap-chunk">2. The Heap Chunk</h1><p>청크는 Heap 메모리 관리를 위한 Heap 메모리 영역의 단위이다. Heap 청크의 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1105</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cm">/*
  This struct declaration is misleading (but accurate and necessary).
  It declares a "view" into memory allowing access to necessary
  fields at known offsets from a given base. See explanation below.
*/</span>

<span class="k">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="cm">/* Size of previous chunk (if free).  */</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="cm">/* Size in bytes, including overhead. */</span>

  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="cm">/* Only used for large blocks: pointer to next larger size.  */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="cm">/* double links -- used only if free. */</span>
  <span class="k">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>실제 할당된 청크</strong>의 레이아웃은 AsciiFlow로 아래와 같이 나타낼 수 있다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span><span class="p">,</span> <span class="k">if</span> <span class="n">allocated</span>            <span class="o">|</span> <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">in</span> <span class="n">bytes</span>                       <span class="o">|</span><span class="n">M</span><span class="o">|</span><span class="n">P</span><span class="o">|</span>
      <span class="n">mem</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">User</span> <span class="n">data</span> <span class="n">starts</span> <span class="n">here</span><span class="p">...</span>                          <span class="p">.</span>
            <span class="p">.</span>                                                               <span class="p">.</span>
            <span class="p">.</span>             <span class="p">(</span><span class="n">malloc_usable_size</span><span class="p">()</span> <span class="n">bytes</span><span class="p">)</span>                      <span class="p">.</span>
            <span class="p">.</span>                                                               <span class="o">|</span>
<span class="n">nextchunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span>                                     <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></table></code></div></div><p>위 레이아웃에서 프로그램에 반환되는 메모리 주소는 <code class="language-plaintext highlighter-rouge">mem</code>이지만, 그 이전에 <code class="language-plaintext highlighter-rouge">INTERNAL_SIZE_T * 2</code>크기의 헤더가 존재한다. (<code class="language-plaintext highlighter-rouge">INTERNAL_SIZE_T</code>는 내부적으로 <code class="language-plaintext highlighter-rouge">size_t</code>의 크기와 동일하게 연산된다.)</p><p><strong>할당 해제된 청크</strong>의 레이아웃은 아래와 같이 나타낼 수 있다.</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>    <span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span>                            <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
    <span class="err">'</span><span class="n">head</span><span class="o">:</span><span class="err">'</span> <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">in</span> <span class="n">bytes</span>                         <span class="o">|</span><span class="n">P</span><span class="o">|</span>
      <span class="n">mem</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Forward</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">next</span> <span class="n">chunk</span> <span class="n">in</span> <span class="n">list</span>             <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Back</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">chunk</span> <span class="n">in</span> <span class="n">list</span>            <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
            <span class="o">|</span>             <span class="n">Unused</span> <span class="n">space</span> <span class="p">(</span><span class="n">may</span> <span class="n">be</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="kt">long</span><span class="p">)</span>                <span class="p">.</span>
            <span class="p">.</span>                                                               <span class="p">.</span>
            <span class="p">.</span>                                                               <span class="o">|</span>
<span class="n">nextchunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
    <span class="err">'</span><span class="n">foot</span><span class="o">:</span><span class="err">'</span> <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">in</span> <span class="n">bytes</span>                           <span class="o">|</span>
            <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></table></code></div></div><p>청크가 해제되면 <code class="language-plaintext highlighter-rouge">mem</code> 위치에 <code class="language-plaintext highlighter-rouge">fd</code>를 설정하고, <code class="language-plaintext highlighter-rouge">mem + sizeof(size_t)</code> 위치에 <code class="language-plaintext highlighter-rouge">bk</code>를 설정하게 된다. 할당 해제된 청크는 이 <code class="language-plaintext highlighter-rouge">fd</code>와 <code class="language-plaintext highlighter-rouge">bk</code>를 통해 <strong>이중 연결 리스트</strong>로 관리된다.</p><p>또한 청크 헤더의 <code class="language-plaintext highlighter-rouge">size</code>위치에 <code class="language-plaintext highlighter-rouge">M, P</code> 등의 값이 붙어있는데, 이는 Heap 메모리가 할당될 때 연산 효율을 위해 할당 크기를 <code class="language-plaintext highlighter-rouge">sizeof(size_t) * 2</code>(32비트에서 8바이트)로 정렬하기 때문에, <code class="language-plaintext highlighter-rouge">size</code> 비트 하위 3비트(1, 2, 4)의 위치에 플래그를 설정하게 된다. 청크 플래그는 3가지가 존재하며, 아래와 같다.</p><h3 id="p-prev_inuse">P (PREV_INUSE)</h3><p>이전 청크(연결 리스트의 이전 인덱스가 아닌, 물리적 메모리로 가장 인접한 청크)가 할당 해제된 상태일 때 0, 사용중일 때 1로 설정된다.</p><p><strong>malloc.c:1269</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cm">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="cp">#define PREV_INUSE 0x1
</span>
<span class="cm">/* extract inuse bit of previous chunk */</span>
<span class="cp">#define prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)
</span></pre></table></code></div></div><h3 id="m-is_mmapped">M (IS_MMAPPED)</h3><p>해당 청크가 <code class="language-plaintext highlighter-rouge">mmap()</code> 함수를 통해 할당되었는지 여부를 표시한다. 이 플래그가 설정되었을 경우, 다른 두가지의 플래그를 무시한다.</p><p><strong>malloc.c:1276</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cm">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="cp">#define IS_MMAPPED 0x2
</span>
<span class="cm">/* check for mmap()'ed chunk */</span>
<span class="cp">#define chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)
</span></pre></table></code></div></div><h3 id="a-non_main_arena">A (NON_MAIN_ARENA)</h3><p>해당 청크가 main arena에 속해있을 경우 0으로 설정된다. 쓰레드가 생성될 때 마다 각각의 arena가 할당되며, 해당 arena에서 청크를 관리하게 되는데, 이때 1로 설정된다.</p><p><strong>malloc.c:1283</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cm">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */</span>
<span class="cp">#define NON_MAIN_ARENA 0x4
</span>
<span class="cm">/* check for chunk from non-main arena */</span>
<span class="cp">#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)
</span></pre></table></code></div></div><hr /><h1 id="3-management-of-chunk--bin">3. Management of Chunk &amp; Bin</h1><p>Heap은 할당 해제된 청크들의 효율적인 관리를 위해 <code class="language-plaintext highlighter-rouge">bin</code>이라는 이름의 단일/이중 연결 리스트를 사용한다. bin은 할당 해제된 청크의 크기에 따라 크게 4가지로 분류된다.</p><ol><li>Fast bin<li>Unsorted bin<li>Small bin<li>Large bin</ol><p>모든 bin은 쓰레드마다 할당되는 <code class="language-plaintext highlighter-rouge">arena</code>에 의해 관리되며, <code class="language-plaintext highlighter-rouge">arena</code> 구조체는 아래와 같이 정의되어 있다.</p><p><strong>malloc.c:1686</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">malloc_state</span>
<span class="p">{</span>
  <span class="cm">/* Serialize access.  */</span>
  <span class="n">mutex_t</span> <span class="n">mutex</span><span class="p">;</span>

  <span class="cm">/* Flags (formerly in max_fast).  */</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

  <span class="cm">/* Fastbins */</span>
  <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>

  <span class="cm">/* Base of the topmost chunk -- not otherwise kept in a bin */</span>
  <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>

  <span class="cm">/* The remainder from the most recent split of a small request */</span>
  <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>

  <span class="cm">/* Normal bins packed as described above */</span>
  <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>

  <span class="cm">/* Bitmap of bins */</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">binmap</span><span class="p">[</span><span class="n">BINMAPSIZE</span><span class="p">];</span>

  <span class="cm">/* Linked list */</span>
  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

  <span class="cm">/* Linked list for free arenas.  Access to this field is serialized
     by free_list_lock in arena.c.  */</span>
  <span class="k">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span>

  <span class="cm">/* Number of threads attached to this arena.  0 if the arena is on
     the free list.  Access to this field is serialized by
     free_list_lock in arena.c.  */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">attached_threads</span><span class="p">;</span>

  <span class="cm">/* Memory allocated from the system in this arena.  */</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>
  <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>위 <code class="language-plaintext highlighter-rouge">arena</code>에서 <code class="language-plaintext highlighter-rouge">Fast bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1694</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cm">/* Fastbins */</span>
<span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span><span class="n">NFASTBINS</span><span class="p">];</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Unsorted bin</code>, <code class="language-plaintext highlighter-rouge">Small bin</code>, <code class="language-plaintext highlighter-rouge">Large bin</code>은 아래와 같이 선언되어 있다.</p><p><strong>malloc.c:1703</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cm">/* Normal bins packed as described above */</span>
<span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span><span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>
</pre></table></code></div></div><h2 id="3-1-fast-bin">3-1. Fast bin</h2><p><code class="language-plaintext highlighter-rouge">16~88 Byte</code>의 크기를 가지는 청크의 경우, <code class="language-plaintext highlighter-rouge">Fast bin</code>으로 관리된다. <code class="language-plaintext highlighter-rouge">Fast bin</code>은 다른 bins와 다르게 단일 연결 리스트로 관리(<code class="language-plaintext highlighter-rouge">fd</code> 필드만 사용)되며, 후입선출(LIFO) 방식으로 관리된다. <code class="language-plaintext highlighter-rouge">Fast bin</code>은 인접한 2개의 청크를 병합하지 않는다. 이로 인해 해제 속도가 빠르지만, 단편화(fragmentation) 가능성이 존재한다.</p><h2 id="3-2-unsorted-bin">3-2. Unsorted bin</h2><p><code class="language-plaintext highlighter-rouge">Small bin</code>과 <code class="language-plaintext highlighter-rouge">Large bin</code>에 들어가야 할 크기의 청크가 해제되었을 때, 바로 <code class="language-plaintext highlighter-rouge">Small/Large Bin</code>에 들어가는 것이 아닌, <code class="language-plaintext highlighter-rouge">Unsorted bin</code>에 저장이 되어 최근 해제한 청크를 빠르게 재사용 가능(캐시 비슷한 역할)하게 만든다.</p><h2 id="3-3-small-bin">3-3. Small bin</h2><p><code class="language-plaintext highlighter-rouge">16~504 Byte</code>의 크기를 가지는 청크의 경우, <code class="language-plaintext highlighter-rouge">Small bin</code>으로 관리된다. 환형 이중 연결 리스트로 관리(<code class="language-plaintext highlighter-rouge">fd</code>, <code class="language-plaintext highlighter-rouge">bk</code> 모두 사용)되며, 선입선출(FIFO) 방식으로 관리된다. 해제되는 청크의 앞 뒤에 존재하는 해제된 청크와 병합을 진행하기 때문에 <code class="language-plaintext highlighter-rouge">Fast bin</code>보다는 느리지만, <code class="language-plaintext highlighter-rouge">Large bin</code>보다는 빠른 속도로 처리된다.</p><h2 id="3-4-large-bin">3-4. Large bin</h2><p>크게 두 부분으로 나뉘는데, 첫번째 Large bin은 <code class="language-plaintext highlighter-rouge">512-568</code>바이트 크기의 청크를, 두번째 Large bin은 <code class="language-plaintext highlighter-rouge">576-632</code>바이트 크기의 청크를 포함한다. 환형 이중 연결 리스트로 관리되며, 사이즈 값에 따라 내림차순으로 정렬된다. <code class="language-plaintext highlighter-rouge">Small bin</code>과 동일하게 할당 해제되었을 때 <code class="language-plaintext highlighter-rouge">Unsorted bin</code> 내에 임시적으로 저장되며, 인접한 할당 해제된 청크에 대해서 병합을 진행한다.</p><h2 id="3-5-top-chunk">3-5. Top chunk</h2><p><code class="language-plaintext highlighter-rouge">Arena</code>의 최상단에 존재하는 청크이다. 동적 메모리 할당 요청이 들어오게 될 경우, 1차적으로 <code class="language-plaintext highlighter-rouge">bins</code>에서 재할당 가능한 청크가 존재하는지 검사하고, 재할당이 불가능하다면 <code class="language-plaintext highlighter-rouge">Top chunk</code>에서 요청한 크기만큼을 떼어 반환한다. 만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Top chunk</code>의 크기보다 크다면 <code class="language-plaintext highlighter-rouge">sbrk()</code> 또는 <code class="language-plaintext highlighter-rouge">mmap()</code> 호출을 통해 확장하며 <code class="language-plaintext highlighter-rouge">PREV_INUSE</code> 플래그가 항상 활성화 되어 있다.</p><h2 id="3-6-last-remainder-chunk">3-6. Last remainder chunk</h2><p>사용자가 작은 크기의 청크를 할당 요청했으나 <code class="language-plaintext highlighter-rouge">Small bin</code>, <code class="language-plaintext highlighter-rouge">Unsorted bin</code>에 존재하는 할당 해제된 청크중 동일한 크기의 청크의 재할당이 불가능할 경우 요청 크기보다 큰 청크를 찾아, 요청 크기만큼 떼어 할당 후 반환한다. 이때 요청 크기만큼 떼고 남은 크기의 청크가 <code class="language-plaintext highlighter-rouge">Last remainder chunk</code>가 된다.</p><hr /><h1 id="4-core-functions">4. Core Functions</h1><p>핵심 함수들은 다음과 같다.</p><h2 id="4-2-void--__libc_malloc-size_t-bytes">4-2. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2901">void * __libc_malloc (size_t bytes)</a></h2><ol><li><code class="language-plaintext highlighter-rouge">__malloc_hook</code>이 설정되어 있다면, <code class="language-plaintext highlighter-rouge">__malloc_hook</code> 포인터를 호출한다.<li><code class="language-plaintext highlighter-rouge">__malloc_hook</code>이 설정되어 있지 않다면, <code class="language-plaintext highlighter-rouge">arena_get()</code> 함수 호출을 통해 <code class="language-plaintext highlighter-rouge">mstate ar_ptr</code> 포인터를 가져온다.<li><code class="language-plaintext highlighter-rouge">ar_ptr</code>, <code class="language-plaintext highlighter-rouge">bytes</code>를 인자로 <code class="language-plaintext highlighter-rouge">_int_malloc()</code>함수를 호출한다.<li><ol><li>만약 <code class="language-plaintext highlighter-rouge">ar_ptr</code>가 <code class="language-plaintext highlighter-rouge">NULL</code>이 아니고, <code class="language-plaintext highlighter-rouge">_int_malloc()</code>함수의 반환값이 <code class="language-plaintext highlighter-rouge">NULL</code>이라면,<ul><li><code class="language-plaintext highlighter-rouge">arena_get_retry()</code> 호출을 통해 다른 Arena Pointer를 <code class="language-plaintext highlighter-rouge">ar_ptr</code>에 받아오고,<li><code class="language-plaintext highlighter-rouge">_int_malloc()</code>함수를 새로운 <code class="language-plaintext highlighter-rouge">ar_ptr</code>을 인자로 다시 실행한다.</ul><li>아니라면,<ul><li>해당 Arena에 대해 <code class="language-plaintext highlighter-rouge">mutex_unlock()</code>를 호출한다.</ul></ol><li>최종적으로 <code class="language-plaintext highlighter-rouge">_int_malloc()</code>의 반환값을 반환하기 전, 아래 사항들을 체크한다.<ul><li><code class="language-plaintext highlighter-rouge">_int_malloc()</code> 반환값(청크)이 <code class="language-plaintext highlighter-rouge">NULL</code>인지<li>청크가 <code class="language-plaintext highlighter-rouge">mmap()</code>을 통해 할당되었는지<li>해당 청크의 아레나가 <code class="language-plaintext highlighter-rouge">2</code>에서 찾은 청크인지</ul><li><code class="language-plaintext highlighter-rouge">5</code>의 내용 중 하나라도 True인 경우, 청크의 포인터를 반환한다.</ol><h2 id="4-1-static-void--_int_malloc-mstate-av-size_t-bytes">4-1. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3318">static void * _int_malloc (mstate av, size_t bytes)</a></h2><ol><li>요청 크기가 범위를 벗어난 값인지 체크 후, <code class="language-plaintext highlighter-rouge">size</code>값을 정렬<sup id="fnref:size_alignment" role="doc-noteref"><a href="#fn:size_alignment" class="footnote" rel="footnote">1</a></sup>한다.<li><code class="language-plaintext highlighter-rouge">av</code>의 값이 NULL인지 체크한다.<li>사용 가능한 <code class="language-plaintext highlighter-rouge">Arena</code>가 존재하지 않을 경우(<code class="language-plaintext highlighter-rouge">av</code>==NULL), <code class="language-plaintext highlighter-rouge">sysmalloc()</code>을 통해 <code class="language-plaintext highlighter-rouge">mmap()</code>을 호출한다. 만약 반환 값이 존재한다면, <code class="language-plaintext highlighter-rouge">alloc_perturb()</code>를 호출한 후 포인터 값을 반환한다.<li><ol><li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Fast bin</code> 범위 안이라면,<li>요청 크기와 동일한 크기의 <code class="language-plaintext highlighter-rouge">Fast bin</code> index를 받아 첫번째 청크를 <code class="language-plaintext highlighter-rouge">victim</code>으로 가져온다.<li>만약 <code class="language-plaintext highlighter-rouge">victim</code>이 NULL이라면, (2)로 넘어간다. (<code class="language-plaintext highlighter-rouge">Small bin</code> 탐색)<li>만약 NULL이 아니라면, <code class="language-plaintext highlighter-rouge">victim</code>의 사이즈가 해당 <code class="language-plaintext highlighter-rouge">Fast bin</code>의 사이즈가 맞는지 체크한다.<ul><li>만약 사이즈가 다르다면, <code class="language-plaintext highlighter-rouge">malloc(): memory corruption (fast)</code>를 출력하고, <code class="language-plaintext highlighter-rouge">malloc_printerr()</code>를 호출한다.<li>만약 사이즈가 동일하다면, 해당 청크의 메모리 포인터를 가져온 후 <code class="language-plaintext highlighter-rouge">alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</ul></ol><li><ol><li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Small bin</code> 범위 안이라면,<li>요청 크기와 동일한 크기의 <code class="language-plaintext highlighter-rouge">Small bin</code> index를 받아 청크를 <code class="language-plaintext highlighter-rouge">victim</code>으로 가져온다.<li>만약 <code class="language-plaintext highlighter-rouge">victim</code>이 <code class="language-plaintext highlighter-rouge">0</code>이라면, <code class="language-plaintext highlighter-rouge">malloc_consolidate()</code>를 호출한다.<li>아니라면, <code class="language-plaintext highlighter-rouge">victim-&gt;bk-&gt;fd != victim</code> 연산을 통해 <code class="language-plaintext highlighter-rouge">victim</code> 청크의 <code class="language-plaintext highlighter-rouge">fd</code>와 <code class="language-plaintext highlighter-rouge">bk</code>가 신뢰할 수 있는 값인지 체크한다.<ul><li>만약 <code class="language-plaintext highlighter-rouge">victim-&gt;bk-&gt;fd != victim</code>이라면, <code class="language-plaintext highlighter-rouge">malloc(): smallbin double linked list corrupted</code>를 출력한다.</ul><li><code class="language-plaintext highlighter-rouge">set_inuse_bit_at_offset()</code> 호출을 통해 <code class="language-plaintext highlighter-rouge">victim</code> 청크의 뒤에 존재하는 청크의 <code class="language-plaintext highlighter-rouge">PREV_INUSE</code> flag를 변경한다.<li><code class="language-plaintext highlighter-rouge">Small bin</code>의 <code class="language-plaintext highlighter-rouge">fd</code> <code class="language-plaintext highlighter-rouge">bk</code>를 재설정함으로써 <code class="language-plaintext highlighter-rouge">victim</code> 청크를 <code class="language-plaintext highlighter-rouge">Small bin</code>에서 제거한다.<li>현재 <code class="language-plaintext highlighter-rouge">Arena</code>가 <code class="language-plaintext highlighter-rouge">main_arena</code>가 아닐 경우, <code class="language-plaintext highlighter-rouge">NON_MAIN_ARENA</code> flag를 설정한다.<li>해당 청크의 메모리 포인터를 가져온 후 <code class="language-plaintext highlighter-rouge">alloc_perturb()</code>를 호출한 뒤 메모리 포인터를 반환한다.</ol><li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Large bin</code> 범위라면,<ul><li>현재 <code class="language-plaintext highlighter-rouge">Arena</code>에 <code class="language-plaintext highlighter-rouge">Fast bin</code> 청크가 존재하는지 확인한 후, 존재한다면 <code class="language-plaintext highlighter-rouge">malloc_consolidate()</code>를 호출하여 청크를 병합한다. (<code class="language-plaintext highlighter-rouge">Fast bin</code> Chunk로 인한 단편화(fragmentation) 방지)</ul><li><ol><li><code class="language-plaintext highlighter-rouge">Unsorted bin</code>에서 청크를 <code class="language-plaintext highlighter-rouge">victim</code>으로 가져온다. 2.<code class="language-plaintext highlighter-rouge">victim</code>의 크기가 최소 크기(<code class="language-plaintext highlighter-rouge">2*SIZE_SZ</code>)보다 작거나 최대 크기(<code class="language-plaintext highlighter-rouge">av-&gt;system_mem</code>)보다 큰지 체크한 후, 작거나 크다면 <code class="language-plaintext highlighter-rouge">malloc(): memory corruption</code>을 출력한다.<li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Small bin</code> 범위이며(<code class="language-plaintext highlighter-rouge">4.2</code>에서 할당이 되었어야 하지만, <code class="language-plaintext highlighter-rouge">bin</code>내에 가용 청크가 없어서 할당되지 못한 경우), <code class="language-plaintext highlighter-rouge">victim</code>이 <code class="language-plaintext highlighter-rouge">Unsorted bin</code> 내의 유일한 청크이며, <code class="language-plaintext highlighter-rouge">victim</code>이 <code class="language-plaintext highlighter-rouge">last_remainder</code> 청크이며, <code class="language-plaintext highlighter-rouge">victim</code>의 크기가 요청 크기보다 클 경우,<ul><li><code class="language-plaintext highlighter-rouge">victim</code> 청크를 <strong>할당된 청크</strong>와 <strong>Last remainder</strong>청크로 나눈 후 header,flag 설정 후 반환한다.</ul><li>위의 4개의 조건이 하나라도 <code class="language-plaintext highlighter-rouge">False</code>일 경우, <code class="language-plaintext highlighter-rouge">victim</code>을 <code class="language-plaintext highlighter-rouge">Unsorted bin</code>에서 제거한다.<li>만약 <code class="language-plaintext highlighter-rouge">victim</code>의 크기가 요청 크기와 정확하게 일치할 경우,<ul><li><code class="language-plaintext highlighter-rouge">PREV_INUSE</code>, <code class="language-plaintext highlighter-rouge">NON_MAIN_ARENA</code> 등의 flag를 설정하고 <code class="language-plaintext highlighter-rouge">alloc_perturb()</code>를 호출한 뒤 해당 청크를 반환한다.</ul><li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Small bin</code> 범위라면,<ul><li>해당 크기의 bin을 가져와 <code class="language-plaintext highlighter-rouge">bck</code>로 설정하고, <code class="language-plaintext highlighter-rouge">bck-&gt;fd</code>를 <code class="language-plaintext highlighter-rouge">fwd</code>로 설정한다.</ul><li>만약 요청 크기가 <code class="language-plaintext highlighter-rouge">Large bin</code> 범위라면,<ul><li><code class="language-plaintext highlighter-rouge">size</code> 필드에 flag bit를 붙이고, <code class="language-plaintext highlighter-rouge">Large bin</code>을 정렬한다.<ul><li>만약 <code class="language-plaintext highlighter-rouge">victim</code>이 마지막 청크(크기가 가장 작은)보다 작다면, 마지막 위치에 삽입한다.<li>아니라면, <code class="language-plaintext highlighter-rouge">victim size</code> &lt;= <code class="language-plaintext highlighter-rouge">chunk size</code>를 찾아 삽입한다. 만약 크기가 같으면 <code class="language-plaintext highlighter-rouge">victim</code>은 <code class="language-plaintext highlighter-rouge">chunk</code> 뒤에 삽입된다.</ul></ul><li><code class="language-plaintext highlighter-rouge">7.1~7</code>의 내용을 최대 10000번 실행한다.</ol></ol><h2 id="4-3-void-__libc_free-void-mem">4-3. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L2933">void __libc_free (void *mem)</a></h2><ol><li>만약, <code class="language-plaintext highlighter-rouge">__free_hook</code>이 설정되어 있다면, <code class="language-plaintext highlighter-rouge">__free_hook</code>을 호출한다.<li><code class="language-plaintext highlighter-rouge">mem</code> 값이 NULL인지 체크한다.<li>할당 해제하려는 청크가 <code class="language-plaintext highlighter-rouge">mmap()</code> 호출을 통해 할당된 청크라면 <code class="language-plaintext highlighter-rouge">munmap_chunk()</code>를 통해 할당 해제한다.<li>아니라면, 해당 청크에 대한 <code class="language-plaintext highlighter-rouge">arena</code>를 가져와 <code class="language-plaintext highlighter-rouge">_int_free()</code>를 호출한다.</ol><h2 id="4-4-static-void-_int_free-mstate-av-mchunkptr-p-int-have_lock">4-4. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L3840">static void _int_free (mstate av, mchunkptr p, int have_lock)</a></h2><ol><li><code class="language-plaintext highlighter-rouge">p &lt; p + chunksize(p)</code>인지, <code class="language-plaintext highlighter-rouge">p</code>가 정렬된 포인터인지 체크한다.<ul><li>만약 아니라면, <code class="language-plaintext highlighter-rouge">free(): invalid pointer</code>를 출력한다.</ul><li><code class="language-plaintext highlighter-rouge">chunksize(p) &lt; MINSIZE</code>인지, 크기가 올바르게 정렬되었는지 체크한다.<ul><li>아니라면, <code class="language-plaintext highlighter-rouge">free(): invalid size</code>를 출력한다.</ul><li>해당 청크의 크기가 <code class="language-plaintext highlighter-rouge">Fast bin</code> 범위인지 체크한다.<ol><li>해당 청크 다음에 존재하는 청크의 크기가 최소 크기 <code class="language-plaintext highlighter-rouge">2*SIZE_SZ</code>보다 작거나, 최대 크기 <code class="language-plaintext highlighter-rouge">av-&gt;system_mem</code>보다 크다면 <code class="language-plaintext highlighter-rouge">free(): invalid next size (fast)</code>를 출력한다.<li>해당 청크에 대해 <code class="language-plaintext highlighter-rouge">free_perturb()</code>를 호출한다.<li><code class="language-plaintext highlighter-rouge">mstate</code>의 <code class="language-plaintext highlighter-rouge">FASTCHUNKS_BIT</code>를 설정한다.<li>해당 크기에 맞는 <code class="language-plaintext highlighter-rouge">Fast bin</code> index를 찾는다.<li>해당 <code class="language-plaintext highlighter-rouge">Fast bin</code> index의 최상단에 있는 청크가 해제하려는 청크인지 확인한 후, 맞다면 <code class="language-plaintext highlighter-rouge">double free or corruption (fasttop)</code>을 출력한다.<li>해당 index의 최상단에 있는 청크의 크기와 해제하려는 청크의 크기를 비교 후, 다르다면 <code class="language-plaintext highlighter-rouge">invalid fastbin entry (free)</code>를 출력한다.<li>해제하려는 청크를 <code class="language-plaintext highlighter-rouge">Fast bin</code> 최상단에 넣고, 끝낸다.</ol><li>만약 해당 청크가 <code class="language-plaintext highlighter-rouge">mmap()</code>을 통해 할당된 청크가 아니라면,<ol><li>만약 해당 청크가 <code class="language-plaintext highlighter-rouge">top chunk</code>라면, <code class="language-plaintext highlighter-rouge">double free or corruption (top)</code>을 출력한다.<li>만약 메모리상의 다음 청크가 해당 <code class="language-plaintext highlighter-rouge">Arena</code>의 영역을 벗어난다면, <code class="language-plaintext highlighter-rouge">double free or corruption (out)</code>을 출력한다.<li>만약 메모리상의 다음 청크의 <code class="language-plaintext highlighter-rouge">PREV_INUSE</code> flag가 설정되어 있지 않다면, <code class="language-plaintext highlighter-rouge">double free or corruption (!prev)</code>를 출력한다.<li>만약 다음 청크의 크기가 최소 크기(<code class="language-plaintext highlighter-rouge">2*SIZE_SZ</code>)보다 작거나 최대 크기(<code class="language-plaintext highlighter-rouge">av-&gt;system_mem</code>)보다 크다면, <code class="language-plaintext highlighter-rouge">free(): invalid next size (normal)</code>을 출력한다.<li>해당 청크에 대해 <code class="language-plaintext highlighter-rouge">free_perturb()</code>를 호출한다.<li>만약 해당 청크의 <code class="language-plaintext highlighter-rouge">PREV_INUSE</code> flag가 설정되어 있지 않다면, 이전 청크에 대해 <code class="language-plaintext highlighter-rouge">unlink</code>를 호출해 병합을 진행한다.<li>만약 다음 청크가 <code class="language-plaintext highlighter-rouge">top Chunk</code>가 아닐 경우,<ul><li>다음 청크가 사용중이지 않을 경우 <code class="language-plaintext highlighter-rouge">unlink</code>를 호출해 병합을 진행한다.<li><code class="language-plaintext highlighter-rouge">unsorted_chunk-&gt;fd-&gt;bk != unsorted_chunk</code>인지 체크한 후, 같지 않다면 <code class="language-plaintext highlighter-rouge">free(): corrupted unsorted chunks</code>를 출력한다.<li>청크를 <code class="language-plaintext highlighter-rouge">Unsorted bin</code>에 넣는다. 8.만약 다음 청크가 <code class="language-plaintext highlighter-rouge">Top Chunk</code>라면 병합을 진행한다.</ul></ol><li>만약 해당 청크가 <code class="language-plaintext highlighter-rouge">mmap()</code>을 통해 할당된 청크라면, <code class="language-plaintext highlighter-rouge">munmap_chunk()</code>을 호출하여 할당 해제한다.</ol><h2 id="4-5-unlinkav-p-bk-fd">4-5. <a href="https://github.com/nonetype/heap-analysis/blob/63f85c0bbe27ef2cd086ca7647b2b3775886f7dc/malloc.c#L1414">unlink(AV, P, BK, FD)</a></h2><ol><li><code class="language-plaintext highlighter-rouge">chunk-&gt;fd-&gt;bk != chunk</code>이거나, <code class="language-plaintext highlighter-rouge">chunk-&gt;bk-&gt;fd != chunk</code>일 경우, <code class="language-plaintext highlighter-rouge">corrupted double-linked list</code>를 출력한다.<li><code class="language-plaintext highlighter-rouge">chunk-&gt;fd = chunk-&gt;bk</code>, <code class="language-plaintext highlighter-rouge">chunk-&gt;bk = chunk-&gt;fd</code>를 수행한다. (이중 연결 리스트에서 해당 청크를 제거한다.)<li>청크의 크기가 <code class="language-plaintext highlighter-rouge">Small bin</code> 범위가 아니라면, <code class="language-plaintext highlighter-rouge">chunk-&gt;fd_nextsize-&gt;bk_nextsize != chunk</code>이거나 <code class="language-plaintext highlighter-rouge">chunk-&gt;bk_nextsize-&gt;fd_nextsize != chunk</code>일 경우, <code class="language-plaintext highlighter-rouge">corrupted double-linked list (not small)</code>을 출력한다.<li><code class="language-plaintext highlighter-rouge">chunk-&gt;fd_nextsize</code>, <code class="language-plaintext highlighter-rouge">chunk-&gt;bk_nextsize</code>에 대해 위와 동일하게 연결 해제한다.</ol><hr /><h1 id="5-error-checks">5. Error Checks</h1><h2 id="5-1-checks-in-_int_malloc">5-1 checks in _int_malloc</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Checks<th style="text-align: left">Error Message<tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">fastbin_index (chunksize (victim)) != idx</code><td style="text-align: left">malloc(): memory corruption (fast)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">victim-&gt;bk-&gt;fd != victim</code><td style="text-align: left">malloc(): smallbin double linked list corrupted<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">victim-&gt;size &lt;= 2 * SIZE_SZ</code> or <code class="language-plaintext highlighter-rouge">victim-&gt;size &gt; av-&gt;system_mem</code><td style="text-align: left">malloc(): memory corruption<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">unsorted-&gt;fd-&gt;bk != unsorted</code><td style="text-align: left">malloc(): corrupted unsorted chunks<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">unsorted-&gt;fd-&gt;bk != unsorted</code>(in best-fit loop)<td style="text-align: left">malloc(): corrupted unsorted chunks 2</table></div><hr /><h2 id="5-2-checks-in-_int_free">5-2 checks in _int_free</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Checks<th style="text-align: left">Error Message<tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">(uintptr_t) p &gt; (uintptr_t) -size</code> or <code class="language-plaintext highlighter-rouge">misaligned_chunk (p)</code><td style="text-align: left">free(): invalid pointer<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">size &lt; MINSIZE</code> or <code class="language-plaintext highlighter-rouge">!aligned_OK (size)</code><td style="text-align: left">free(): invalid size<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">next-&gt;size &lt;= 2 * SIZE_SZ</code> or <code class="language-plaintext highlighter-rouge">next-&gt;size &gt;= av-&gt;system_mem</code><td style="text-align: left">free(): invalid next size (fast)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">top(fastbin) == p</code><td style="text-align: left">double free or corruption (fasttop)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">old_idx != idx</code><td style="text-align: left">invalid fastbin entry (free)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">p == av-&gt;top</code><td style="text-align: left">double free or corruption (top)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">nextchunk &gt; = ((char *) av-&gt;top + chunksize(av-&gt;top))</code><td style="text-align: left">double free or corruption (out)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">!prev_inuse(nextchunk)</code><td style="text-align: left">double free or corruption (!prev)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">nextsize &gt;= av-&gt;system_mem</code><td style="text-align: left">free(): invalid next size (normal)<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">fwd-&gt;bk != bck</code><td style="text-align: left">free(): corrupted unsorted chunks</table></div><hr /><h2 id="5-3-checks-in-unlink">5-3 checks in unlink</h2><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Checks<th style="text-align: left">Error Message<tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">FD-&gt;bk != P</code> or <code class="language-plaintext highlighter-rouge">BK-&gt;fd != P, 0</code><td style="text-align: left">corrupted double-linked list<tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">P-&gt;fd_nextsize-&gt;bk_nextsize != P</code> or <code class="language-plaintext highlighter-rouge">P-&gt;bk_nextsize-&gt;fd_nextsize != P</code><td style="text-align: left">corrupted double-linked list (not small)</table></div><hr /><h1 id="마치며">마치며..</h1><p>전에는 단순히 다른 사람이 정리해놓은 문서를 보고 필요한 만큼만 이해했었는데, 이 문서를 쓰면서 bin을 찾는 과정이나, bin에 넣는 과정 등등을 알아갈 수 있었다.</p><p>아쉬운 점은 세부적으로 분석은 많이 했는데 간단하게 표현을 하지 못한 점, 많은 부분(힙익스 페이로드를 놓고, 어떻게 동작하는지, 어떤 부분을 이용한건지 등등)을 써보고 싶었지만 팀프로젝트 기간이라 당장 리눅스 커널 익스를 해야하는 형국이라 나중에 시간이 나게 되면 추가적으로 문서화하도록 해야겠다.</p><p>리눅스 커널 익스하면서도 kmalloc, vmalloc 등 특이한 동적 메모리 관리 방법도 알아가는 중이라 틈틈히 추가하고 다듬는 과정을 통해서 더 정확하고, 유익한 정보가 있는 문서가 되었으면 좋겠다.</p><hr /><h1 id="references">References</h1><p>[Understanding glibc malloc 번역] <a href="https://tribal1012.tistory.com/78">https://tribal1012.tistory.com/78</a></p><p>[Heap 영역 정리] <a href="https://tribal1012.tistory.com/141">https://tribal1012.tistory.com/141</a></p><p>[Hacker’s Hut: Exploiting the heap] <a href="https://www.win.tue.nl/~aeb/linux/hh/hh-11.html">https://www.win.tue.nl/~aeb/linux/hh/hh-11.html</a></p><p>[glib malloc] <a href="https://umbum.tistory.com/386">https://umbum.tistory.com/386</a></p><div class="footnotes" role="doc-endnotes"><ol><li id="fn:size_alignment" role="doc-endnote"><p><code class="language-plaintext highlighter-rouge">sizeof(size_t) * 2</code>(32비트에서 8바이트) 단위로 정렬된다. <a href="#fnref:size_alignment" class="reversefootnote" role="doc-backlink">&#8617;</a></p></ol></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/pwn/'>pwn</a>, <a href='/categories/linux/'>linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/heap/" class="post-tag no-text-decoration" >heap</a> <a href="/tags/analysis/" class="post-tag no-text-decoration" >analysis</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=malloc.c Analysis - do:pwn()&url=https://nonetype.kr/posts/malloc/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=malloc.c Analysis - do:pwn()&u=https://nonetype.kr/posts/malloc/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=malloc.c Analysis - do:pwn()&url=https://nonetype.kr/posts/malloc/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/DLL-Hijacking/">DLL Hijacking Note</a><li><a href="/posts/BlazeCTF2018-blazeme-write-up/">blazeme - BlazeCTF 2018</a><li><a href="/posts/Linux-Kernel-Exploit-Development-lab1/">Linux Kernel Exploit Development (Part 1/10)</a><li><a href="/posts/Linux-Kernel-Exploit-Development-lab2/">Linux Kernel Exploit Development (Part 2/10)</a><li><a href="/posts/Linux-Kernel-Exploit-Development-lab3/">Linux Kernel Exploit Development (Part 3/10)</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/debugging/">debugging</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/firefox/">firefox</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/1-day/">1-day</a> <a class="post-tag" href="/tags/analysis/">analysis</a> <a class="post-tag" href="/tags/ctf/">ctf</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Linux-Kernel-Heap-Spraying/"><div class="card-body"> <span class="timeago small" > Nov 14, 2019 <i class="unloaded">2019-11-14T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux kernel Heap Spraying Techniques</h3><div class="text-muted small"><p> some Techniques to Spraying Linux kernel heap 목차 목차 Heap Spraying add_key() Spraying Example Overview Syscall Analysis send[m]msg() Spraying ...</p></div></div></a></div><div class="card"> <a href="/posts/Linux-Kernel-Exploit-Development-lab1/"><div class="card-body"> <span class="timeago small" > Sep 23, 2019 <i class="unloaded">2019-09-23T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux Kernel Exploit Development (Part 1/10)</h3><div class="text-muted small"><p> Linux Kernel Exploit Development with VMware - Lab1::Debugging Environment 목차 목차 Debugging Environment Debugger Attach Debug Program Debugging Environment 우선 디버깅 환경을 살펴보니 MasterVM와...</p></div></div></a></div><div class="card"> <a href="/posts/Linux-Kernel-Exploit-Development-lab2/"><div class="card-body"> <span class="timeago small" > Sep 23, 2019 <i class="unloaded">2019-09-23T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux Kernel Exploit Development (Part 2/10)</h3><div class="text-muted small"><p> Linux Kernel Exploit Development with VMware - Lab2::Module Debugging 목차 목차 The Kernel Module Debugger Attach to Kernel Module Debug Kernel Module The Kernel Module TestVM의 mod_sam...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Linux-Kernel-Exploit-Development-lab4/" class="btn btn-outline-primary" prompt="Older"><p>Linux Kernel Exploit Development (Part 4/10)</p></a> <a href="/posts/Linux-Kernel-Heap-Spraying/" class="btn btn-outline-primary" prompt="Newer"><p>Linux kernel Heap Spraying Techniques</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/nonetype_pwn">Wonyoung Jung</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/kernel/">kernel</a> <a class="post-tag" href="/tags/exploit/">exploit</a> <a class="post-tag" href="/tags/debugging/">debugging</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/firefox/">firefox</a> <a class="post-tag" href="/tags/heap/">heap</a> <a class="post-tag" href="/tags/1-day/">1 day</a> <a class="post-tag" href="/tags/analysis/">analysis</a> <a class="post-tag" href="/tags/ctf/">ctf</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://nonetype.kr{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
